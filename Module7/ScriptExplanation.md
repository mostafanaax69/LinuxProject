# System Health Check and Monitor

## Explaining the code line by line:
Every line is well commented and documented , but here is a wider documentation : 


- Logging :
  In order to log all of the messages in a proper way , i have created a new log in the script and saved its location in the `log_file` variable.
    ```bash
        log() {
        echo "$(date +"%Y-%m-%d %H:%M:%S") $1" >> "$log_file"
          }
This function is responsible for logging the sent line into the log_file variable which we defined before , in a well orginaized manner and  timestamped logs of each health check included.
  In the script, you'll find several instances of `log $line` after specific commands. It is a call for the function log which redirects the standard output of a command to a file without overwriting the file's existing content ( because of using the " >> " operator)

  
  
- Function to send email :
  In order send an email as requested , the send_email function takes the `log_file` by using the `cat` command and then the `mail` command to send it to the `recipient_email` variable which is defined above in the script with the `subject` variable that we have set before.
    ```bash
        send_email() {
            cat "$log_file" | mail -s "$subject" "$recipient_email" }


  
  
- Essential services check :
    ```bash
         essential_services=("ssh" "http" "https" "mysql")
          for service in "${essential_services[@]}"; do
              if systemctl is-active --quiet $service; then
                  log "$service is running."
              else
                  log "$service is down."
              fi
          done

- `essential_services=("ssh" "http" "https" "mysql")` : This line defines an array named essential_services containing the names of essential services: SSH, HTTP, HTTPS, and MySQL.
- The for loop iterates over every service in the array.
- `systemctl is-active` is a linux command that checks if each service is currently active. The `--quiet` option makes systemctl operate quietly, only returning a success or failure exit status.



- Disk usage check :
    ```bash
    threshold=80
    df -h | awk '$5 > '$threshold' {print "Partition " $6 " is over '$threshold'% usage."}' | while read -r line; do
        log "$line"
    done

- `df -h` : This command is used to display information about disk space usage. The -h option formats the output in a human-readable format, using sizes like KB, MB, GB, etc.
- The output of the command `df -h:` is then passed to the `awk` (text processing tool ) command using `|`
- `awk '$5 > '$threshold' {print "Partition " $6 " is over '$threshold'% usage."}'` : generates output based on disk space usage using the df command and filters the output using awk to select lines where disk usage (the fifth column ) is greater than the specified threshold.
- The loop par reads each line of the output generated by the previous command (filtered by awk) , and assigns it to the line variable to log it


- CPU and memory usage check:
    ```bash
    cpu_threshold=50
    ram_threshold=2000000  # 2GB in kilobytes
    ps -eo pid,%cpu,%mem,cmd | awk '$2 > '$cpu_threshold' || $3 > '$ram_threshold' {print "High resource usage: PID=" $1 " CPU=" $2 "% RAM=" $3 "% Command=" $4}' | while read -r line; do
        log "$line"
    done

- Same as Disk usage check , the awk command filters the output of the `ps` command , and filters all of the lines that their second and third column (cpu and ram ultilaztion columns )are higher than the cpu_threshold and ram_threshold respectivly.





- System logs analysis :
    ```bash
       error_logs=$(grep -iE 'error|warning' /var/log/syslog)
          if [ -n "$error_logs" ]; then
              log "=== Error or Warning Messages in System Logs ==="
              log "$error_logs"
          else
              log "No error or warning messages in system logs."
          fi

- `error_logs=$(grep -iE 'error|warning' /var/log/syslog)` : This command uses `grep` to search for lines in the `/var/log/syslog ` file that contain the strings 'error' or 'warning' , the iE flags are for case senstive and interpreting the pattern as an extended regular expression to use the `|` .
- `if [ -n "$error_logs" ]; then` : This is an if statement that checks whether the variable error_logs has a non-zero length, meaning that there are error or warning messages found in the logs , if yes then it logs them.




- Failed SSH login sessions:
    ```bash
      failed_ssh_logins=$(grep 'Failed password' /var/log/auth.log | awk '{print $1, $2, $3, $9}' | sort | uniq -c)
      if [ -n "$failed_ssh_logins" ]; then
          log "=== Failed SSH Login Attempts ==="
          log "$failed_ssh_logins"
      else
          log "No failed SSH login attempts."
      fi

- `failed_ssh_logins=$(grep 'Failed password' /var/log/auth.log | awk '{print $1, $2, $3, $9}' | sort | uniq -c)` : This command uses `grep` to search for lines in the `/var/log/auth.log ` , with the use of other text proessing commands.
- `if [ -n "$failed_ssh_logins" ]; then` : This is an if statement that checks whether the variable failed_ssh_logins has a non-zero length, meaning that there failed loging found in the logs , if yes then it logs them.




- Open ports scan
    ```bash
    open_ports=$(ss -tuln | awk '$1 == "LISTEN" {print $5}' | cut -d':' -f2)
    log "=== Open Ports ==="
    log "$open_ports"


-`ss -tuln `: This command is used to display socket statistics, including listening sockets (-l) and numeric output (-n).

- `failed_ssh_logins=$(grep 'Failed password' /var/log/auth.log | awk '{print $1, $2, $3, $9}' | sort | uniq -c)` : This command uses `grep` to search for lines in the `/var/log/auth.log ` , with the use of other text proessing commands.
- awk '$1 == "LISTEN" {print $5}': This awk command filters the output to only include lines where the first column is "LISTEN," and it prints the fifth column (the address and port information).
- cut -d':' -f2: This cut command extracts the part after the colon, which represents the port number.
- The entire command extracts and stores the open port numbers in the open_ports variable and then sends it to the log function



  
